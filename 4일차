# MongoDB 기초 및 개념

1. **MongoDB는 어떤 유형의 데이터베이스이며, 어떤 형식으로 데이터를 저장합니까? MongoDB의 스키마 특성에 대해 설명하세요.**
MongoDB는 NoSQL 데이터베이스로, 비관계형 데이터베이스 관리 시스템입니다. 주로 문서 지향 데이터베이스로 분류되며, 데이터를 BSON (Binary JSON) 형식으로 저장합니다. BSON은 JSON의 확장으로, 다양한 데이터 타입을 지원하고, 효율적인 저장과 검색을 가능하게 합니다.

2. **MongoDB에서 문서(Document)와 컬렉션(Collection)의 개념을 설명하고, SQL에서 테이블(Table)과의 차이점을 비교하세요.**
문서, 컬렉션, sql의 테이블  
차이점 : 스카미, 데이터 형식, 관계, 유연성 이러한 차이점 덕분에 MongoDB는 비정형 데이터와 빠른 개발이 필요한 상황에서 유리한 선택이 될 수 있습니다.

3. **MongoDB에서 스키마리스(Schemaless) 데이터베이스의 장점과 단점을 설명하세요.**
장점 : 유연성, 빠른 개발, 복잡한 데이터 구조 지원, 데이터 다양성
단점 : 데이터 일관성, 복잡한 쿼리, 성능저하, 데이터 모델링의 어려움 
이러한 장점과 단점을 고려하여, 스키마리스 데이터베이스를 사용할지 여부를 결정하는 것이 중요합니다. 각 프로젝트의 요구사항에 맞는 데이터베이스 유형을 선택하는 것이 핵심입니다.

4. **MongoDB의 주요 특징 중 수평적 확장성에 대해 설명하고, 샤딩(Sharding)이 어떻게 수평적 확장을 지원하는지 서술하세요.**
**수평적 확장성 (Horizontal Scalability)**은 데이터베이스가 더 많은 서버(노드)를 추가하여 성능을 향상시키거나 저장 용량을 늘릴 수 있는 능력을 의미합니다. MongoDB는 이러한 수평적 확장성을 지원하여 대규모 데이터베이스 환경에서 효율적으로 운영할 수 있도록 설계되었습니다.
샤딩은 MongoDB에서 수평적 확장성을 지원하는 주요 기술로, 데이터를 여러 서버에 분산 저장하는 방식입니다. 이 방법은 데이터가 특정 한계를 초과할 때, 성능 저하를 방지하고 대용량 데이터를 처리하기 위해 사용됩니다.

5. **MongoDB에서 BSON(Binary JSON) 형식이 사용되는 이유와 이 형식의 주요 특징에 대해 설명하세요.**
주된 이유 : 효율적인 저장, 다양한 데이터 타입 지원, 빠른 데이터 처리, 중첩 구조 지원
주요 특징 : 이진 형식, 유연한 데이터 구조, 메타데이터 포함, 정렬된 데이터, 유연한 크기
이러한 이유로 BSON 형식은 MongoDB의 데이터 저장 및 처리에 있어 매우 중요한 역할을 하며, MongoDB의 성능과 유연성을 높이는 데 기여합니다.


---

# MongoDB 트랜잭션 관련

1. **MongoDB에서 멀티 도큐먼트 트랜잭션(Multi-Document Transaction)이 무엇이며, 어떻게 작동하는지 설명하세요.**
멀티 도큐먼트 트랜잭션은 MongoDB에서 여러 문서에 대한 일관성 있는 작업을 수행할 수 있는 기능입니다. 이를 통해 여러 데이터베이스 연산을 하나의 원자적(atomic) 단위로 묶을 수 있어, 모든 작업이 성공적으로 완료되거나, 하나라도 실패할 경우 모든 작업이 롤백됩니다.
작동 방식 : 트랜잭션 시작, 작업 수행, 트랜잭션 커밋, 트랜잭션 롤백
주요특징 : acid속성, 여러 데이터베이스 지원, 서능 고려사

2. **MongoDB 트랜잭션의 ACID 속성(Atomicity, Consistency, Isolation, Durability)에 대해 설명하고, 각 속성이 트랜잭션에서 어떤 역할을 하는지 서술하세요.**
MongoDB 트랜잭션은 ACID 속성을 지원하여 데이터의 무결성과 일관성을 보장합니다
원자성 : 원자성 덕분에 트랜잭션의 중간 상태가 외부에 노출되지 않습니다. 예를 들어, 두 개의 문서에 대한 업데이트가 포함된 트랜잭션에서 한 문서의 업데이트만 성공하고 다른 문서의 업데이트가 실패하면, 전체 트랜잭션이 롤백되어 데이터의 일관성을 유지할 수 있습니다.\

일관성 : 일관성 속성은 트랜잭션이 시작되기 전과 후의 데이터베이스 상태가 유효해야 함을 보장합니다. 예를 들어, 특정 조건을 만족해야 하는 데이터 필드가 있을 경우, 트랜잭션 내에서 모든 변경이 완료되면 이러한 조건이 여전히 만족되도록 합니다.

고립성 : 고립성은 동시에 실행되는 트랜잭션들이 서로 간섭하지 않도록 보장합니다. 이 속성 덕분에 여러 트랜잭션이 동시에 실행되더라도 데이터의 무결성이 유지됩니다. 예를 들어, 두 개의 트랜잭션이 동시에 동일한 데이터를 업데이트하려고 할 때, 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션은 대기해야 합니다.

지속성 : 역할: 지속성은 트랜잭션이 완료된 후 그 결과가 데이터베이스에 안정적으로 저장되어, 시스템 장애나 오류가 발생하더라도 데이터가 손실되지 않도록 보장합니다. 즉, 트랜잭션이 성공적으로 커밋된 경우, 해당 데이터는 언제든지 복구할 수 있어야 합니다.


3. **M**ongoDB 트랜잭션 사용 시, 데이터 일관성을 보장하기 위해 사용하는 `commitTransaction()`과 `abortTransaction()` 메서드의 역할을 설명하세요.
MongoDB 트랜잭션 사용 시 데이터 일관성을 보장하기 위해 사용하는 commitTransaction()과 abortTransaction() 메서드는 각각 다음과 같은 역할을 수행합니다.
commitTransaction(): 모든 변경 사항을 데이터베이스에 영구적으로 반영하여, 트랜잭션이 성공적으로 완료되었음을 나타냅니다.
abortTransaction(): 모든 변경 사항을 취소하고, 트랜잭션 시작 전의 상태로 되돌려, 데이터의 일관성을 보장합니다.

4. MongoDB에서 트랜잭션을 사용할 수 있는 환경을 설**명하고, 단일 인스턴스에서 트랜잭션이 가능한지 여부를 기술하세요.**
MongoDB에서 트랜잭션을 사용하려면 Replica Set 환경이 필요하며, 단일 인스턴스에서는 트랜잭션 기능을 사용할 수 없습니다. 이러한 구조는 데이터 일관성과 안정성을 높이기 위해 설계되었습니다.


5. **MongoDB에서 트랜잭션을 구현한 예시 코드를 제시하고, 각 단계별로 동작 방식을 설명하세요.**

---MongoClient 생성 및 연결:

MongoClient를 생성하고, 데이터베이스에 연결합니다. 이 단계에서 MongoDB 서버에 연결하여 사용할 데이터베이스와 컬렉션을 정의합니다.
세션 시작:

session.startSession()을 호출하여 트랜잭션을 위한 세션을 시작합니다. 이 세션은 트랜잭션 내에서 수행될 모든 작업을 관리합니다.
트랜잭션 시작:

session.startTransaction()을 호출하여 트랜잭션을 시작합니다. 이 시점부터 수행되는 모든 작업은 원자적으로 처리됩니다.
첫 번째 문서 삽입:

collection1.insertOne()을 호출하여 첫 번째 컬렉션에 문서를 삽입합니다. { session } 인자를 전달하여 이 작업이 트랜잭션의 일환임을 명시합니다.
두 번째 문서 삽입:

collection2.insertOne()을 호출하여 두 번째 컬렉션에 문서를 삽입합니다. 이 작업도 마찬가지로 트랜잭션 내에서 처리됩니다.
트랜잭션 커밋:

모든 작업이 성공적으로 완료되면 session.commitTransaction()을 호출하여 변경 사항을 데이터베이스에 영구적으로 반영합니다. 이 시점에서 두 문서가 데이터베이스에 저장됩니다.
오류 처리 및 롤백:

트랜잭션 중 오류가 발생하면 catch 블록으로 넘어가 session.abortTransaction()을 호출하여 모든 변경 사항을 롤백합니다. 이로 인해 데이터의 일관성이 유지됩니다.
세션 종료 및 클라이언트 닫기:

session.endSession()을 호출하여 세션을 종료하고, client.close()를 호출하여 데이터베이스 연결을 종료합니다.


# 샤딩(Sharding) 관련

1. **MongoDB에서 샤딩(Sharding)이란 무엇이며, 이를 통해 데이터베이스 성능을 어떻게 최적화할 수 있는지 설명하세요.**
**샤딩(Sharding)**은 MongoDB에서 데이터를 수평적으로 분산 저장하는 방법으로, 대규모 데이터베이스 환경에서 성능과 확장성을 개선하기 위해 사용됩니다. 샤딩은 데이터를 여러 샤드(shard)라는 개별 데이터베이스 서버에 분산하여 저장함으로써, 각 서버가 데이터의 일부만 처리하도록 하여 전체 시스템의 부하를 줄입니다.


2. **MongoDB에서 샤드 키(Shard Key)의 역할과, 샤드 키를 선택할 때 고려해야 할 요소들을 설명하세요.**
샤드 키(Shard Key)**는 MongoDB에서 데이터를 샤딩(sharding)하는 데 사용되는 필드로, 데이터가 어떤 샤드에 저장될지를 결정합니다
샤드 키는 MongoDB에서 샤딩을 구현하는 데 있어 중요한 요소로, 데이터 분산, 쿼리 성능, 데이터 관리에 큰 영향을 미칩니다. 샤드 키를 선택할 때는 데이터 분포, 쿼리 패턴, 카디널리티, 성능 및 미래 데이터 성장 등을 충분히 고려해야 하며, 이를 통해 시스템의 성능과 안정성을 최적화할 수 있습니다.

3. **MongoDB에서 샤딩 구조의 주요 구성 요소(샤드, 쿼리 라우터, 컨피그 서버)를 설명하고, 각 구성 요소가 어떻게 상호작용하는지 서술하세요.**

MongoDB의 샤딩 구조는 다음 세 가지 주요 구성 요소로 구성됩니다: 샤드(Shard), 쿼리 라우터(Query Router), 컨피그 서버(Config Server).
이러한 구성 요소들은 MongoDB의 샤딩 구조에서 서로 긴밀하게 상호작용하며, 데이터의 효율적인 분산 저장과 고속의 쿼리 처리를 가능하게 합니다. 이를 통해 대규모 데이터베이스 환경에서도 안정적이고 일관된 성능을 제공할 수 있습니다.


4. **MongoDB에서 Range-based Sharding과 Hash-based Sharding의 차이점을 설명하고, 각각의 장단점을 비교하세요.**
MongoDB에서 Range-based Sharding과 Hash-based Sharding은 데이터를 샤딩하는 두 가지 주요 방법입니다
장점: 직관적인 데이터 접근: 쿼리가 특정 범위의 데이터를 요청할 때, 해당 범위를 가진 샤드로 직접 접근할 수 있어 성능이 좋습니다.
유사한 값의 집합: 연속적인 값의 범위를 가지는 경우, 같은 샤드에 비슷한 데이터를 저장하므로 캐시 효과가 발생할 수 있습니다.

단점: 데이터 불균형: 특정 값이 많이 몰리는 경우(예: 특정 날짜), 데이터가 한 샤드에 집중되어 부하가 불균형하게 분산될 수 있습니다.
확장성 문제: 새로운 샤드를 추가할 때 기존 데이터의 재분배가 필요할 수 있으며, 이로 인해 성능 저하가 발생할 수 있습니다.

5. **MongoDB에서 샤딩의 장점과 단점을 설명하고, 샤딩이 적합한 상황과 그렇지 않은 상황에 대해 논하세요.**

---MongoDB의 샤딩은 대규모 데이터베이스의 성능과 확장성을 향상시키는 강력한 도구입니다. 그러나 샤딩의 장점과 단점을 잘 이해하고, 특정 상황에서 적합한지 여부를 판단해야 합니다. 샤딩이 필요한 환경에서는 이를 잘 설계하여 운영해야 하며, 그렇지 않은 환경에서는 단순한 데이터베이스 구조를 유지하는 것이 더 효율적일 수 있습니다.


# 레플리카 세트(Replica Set) 관련

1. **MongoDB에서 레플리카 세트(Replica Set)란 무엇이며, 이 기능을 사용하는 주된 목적에 대해 설명하세요.**
**레플리카 세트(Replica Set)**는 MongoDB에서 고가용성 및 데이터 복구 기능을 제공하기 위해 사용되는 데이터베이스 구성입니다. 레플리카 세트는 하나의 주(primary) 노드와 하나 이상의 보조(secondary) 노드로 구성됩니다. 주 노드는 데이터에 대한 모든 읽기 및 쓰기 작업을 처리하며, 보조 노드는 주 노드의 데이터를 복제하여 저장합니다.


2. **MongoDB 레플리카 세트의 구성 요소인 Primary, Secondary, Arbiter의 역할과 동작 방식을 설명하세요.**

MongoDB 레플리카 세트는 데이터의 고가용성 및 복구 기능을 제공하기 위해 여러 구성 요소로 이루어져 있습니다.
Primary, Secondary, Arbiter는 MongoDB 레플리카 세트의 중요한 구성 요소로, 데이터의 일관성, 가용성, 복구를 보장하는 데 중요한 역할을 합니다. 이러한 구성 요소들이 상호작용하여 클러스터의 안정성을 높이며, 장애 발생 시에도 신속한 복구를 가능하게 합니다.

3. **MongoDB에서 레플리카 세트를 사용하는 경우, Primary 서버에 장애가 발생했을 때 어떤 과정으로 장애를 복구하는지 서술하세요.**
MongoDB에서 Primary 서버에 장애가 발생했을 때, 레플리카 세트는 자동으로 새로운 Primary를 선출하여 시스템의 가용성을 유지합니다. 이 과정은 장애 감지, 투표 및 선출, 복구, 데이터 동기화 등으로 이루어져 있으며, 이를 통해 안정적인 데이터베이스 환경을 제공합니다.

4. **MongoDB에서 Secondary 서버를 활용한 읽기 작업 분산이 무엇인지 설명하고, 이 방법이 읽기 성능에 어떤 영향을 미치는지 논하세요.**
MongoDB의 레플리카 세트에서 Secondary 서버를 활용한 읽기 작업 분산은 주로 읽기 요청을 여러 Secondary 서버로 분산하여 처리하는 방법을 의미합니다. 이 기능은 데이터베이스의 부하를 줄이고 읽기 성능을 향상시키는 데 도움을 줍니다.
MongoDB에서 Secondary 서버를 활용한 읽기 작업 분산은 데이터베이스의 읽기 성능을 극대화하는 효과적인 방법입니다. 읽기 요청을 여러 서버로 분산시켜 부하를 줄이고 응답 속도를 향상시키는 한편, 데이터 일관성을 고려해야 합니다. 적절한 읽기 우선 순위 설정을 통해 시스템의 요구에 맞는 최적의 성능을 구현할 수 있습니다.

5. **레플리카 세트와 샤딩의 차이점을 설명하고, 두 기능을 함께 사용할 경우의 장점에 대해 서술하세요.**

---레플리카 세트와 샤딩은 각기 다른 목적을 가지고 있지만, 함께 사용할 경우 시스템의 안정성, 성능, 확장성을 극대화할 수 있습니다. 이러한 조합은 대규모 데이터베이스 환경에서 특히 효과적이며, 데이터 처리의 효율성을 높이는 데 기여합니다.
